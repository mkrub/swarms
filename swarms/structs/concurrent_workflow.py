import asyncio
import os
import re
import uuid
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Union

from pydantic import BaseModel, Field

from swarms.structs.agent import Agent
from swarms.structs.base_swarm import BaseSwarm
from swarms.utils.file_processing import create_file_in_folder
import concurrent.futures
from swarms.utils.loguru_logger import initialize_logger
from swarms.structs.conversation import Conversation
from swarms.structs.swarm_id_generator import generate_swarm_id

logger = initialize_logger(log_folder="concurrent_workflow")

class AgentOutputSchema(BaseModel):
    run_id: Optional[str] = Field(
        ..., description="Unique ID for the run"
    )
    agent_name: Optional[str] = Field(
        ..., description="Name of the agent"
    )
    task: Optional[str] = Field(
        ..., description="Task or query given to the agent"
    )
    output: Optional[str] = Field(
        ..., description="Output generated by the agent"
    )
    start_time: Optional[datetime] = Field(
        ..., description="Start time of the task"
    )
    end_time: Optional[datetime] = Field(
        ..., description="End time of the task"
    )
    duration: Optional[float] = Field(
        ...,
        description="Duration taken to complete the task (in seconds)",
    )

class MetadataSchema(BaseModel):
    swarm_id: Optional[str] = Field(
        generate_swarm_id(), description="Unique ID for the run"
    )
    task: Optional[str] = Field(
        ..., description="Task or query given to all agents"
    )
    description: Optional[str] = Field(
        "Concurrent execution of multiple agents",
        description="Description of the workflow",
    )
    agents: Optional[List[AgentOutputSchema]] = Field(
        ..., description="List of agent outputs and metadata"
    )
    timestamp: Optional[datetime] = Field(
        default_factory=datetime.now,
        description="Timestamp of the workflow execution",
    )

class ConcurrentWorkflow(BaseSwarm):
    def __init__(
        self,
        name: str = "ConcurrentWorkflow",
        description: str = "Execution of multiple agents concurrently",
        agents: List[Union[Agent, Callable]] = [],
        metadata_output_path: str = "agent_metadata.json",
        auto_save: bool = True,
        output_schema: BaseModel = MetadataSchema,
        max_loops: int = 1,
        return_str_on: bool = False,
        agent_responses: list = [],
        auto_generate_prompts: bool = False,
        max_workers: int = None,
        *args,
        **kwargs,
    ):
        print(f"\nğŸŒ€ Initializing ConcurrentWorkflow: {name}")
        print(f"ğŸ“ Description: {description}")
        print(f"ğŸ”„ Max loops: {max_loops}")
        
        self._validate_metadata_path(metadata_output_path)
        
        super().__init__(
            name=name,
            description=description,
            agents=agents,
            *args,
            **kwargs,
        )
        
        self.name = name
        self.description = description
        self.agents = agents
        self.metadata_output_path = metadata_output_path
        self.auto_save = auto_save
        self.output_schema = output_schema
        self.max_loops = max_loops
        self.return_str_on = return_str_on
        self.agent_responses = agent_responses
        self.auto_generate_prompts = auto_generate_prompts
        self.max_workers = max_workers or os.cpu_count()
        self.tasks = []
        self.conversation = Conversation()

        print(f"ğŸ¤– Number of agents: {len(self.agents)}")
        print(f"ğŸ’¾ Metadata output: {self.metadata_output_path}")
        print(f"ğŸš€ Max workers: {self.max_workers}")
        
        self.reliability_check()
        print("âœ… Workflow initialized successfully\n")

    def _validate_metadata_path(self, path: str):
        if re.search(r"\.\./", path):
            raise ValueError("Path contains traversal characters")
        if os.path.isabs(path):
            raise ValueError("Absolute paths not allowed")
        if not path.endswith(".json"):
            raise ValueError("Only JSON files allowed")

    def save_metadata(self):
        if not self.auto_save:
            return

        try:
            print("\nğŸ’¾ Starting metadata save process...")
            base_dir = Path(os.getenv("WORKSPACE_DIR", ".")).resolve()
            output_path = (base_dir / self.metadata_output_path).resolve()

            if not output_path.parent.samefile(base_dir):
                raise ValueError(f"Path traversal attempt: {output_path}")

            output_path.parent.mkdir(parents=True, exist_ok=True)
            temp_path = output_path.with_suffix(".tmp")
            
            with open(temp_path, "w", encoding="utf-8") as f:
                f.write(self.output_schema.model_dump_json(indent=4))
            os.chmod(temp_path, 0o600)
            os.replace(temp_path, output_path)
            
            print(f"ğŸ“ Metadata saved to: {output_path}")
            print(f"ğŸ”’ File permissions set to: {oct(os.stat(output_path).st_mode)[-3:]}")
            
        except Exception as e:
            print(f"âŒ Metadata save failed: {str(e)}")
            raise

    def reliability_check(self):
        try:
            print("ğŸ”’ Starting reliability checks...")
            if not self.agents:
                raise ValueError("Agents list cannot be empty")
            if any(not isinstance(agent, Agent) for agent in self.agents):
                raise TypeError("Invalid agent type detected")
            print("ğŸ” All checks passed")
            
        except Exception as e:
            print(f"ğŸš¨ Reliability check failed: {str(e)}")
            raise

    def _run(self, task: str, img: str = None, *args, **kwargs):
        print(f"\nğŸš€ Starting task execution: {task[:50]}...")
        start_time = datetime.now()
        
        def run_agent(agent: Agent, task: str, img: str = None):
            agent_start = datetime.now()
            print(f"\nğŸ¤– Agent {agent.agent_name} starting task...")
            
            try:
                output = agent.run(task=task, img=img)
                duration = (datetime.now() - agent_start).total_seconds()
                print(f"âœ… {agent.agent_name} completed in {duration:.2f}s")
                return AgentOutputSchema(
                    run_id=uuid.uuid4().hex,
                    agent_name=agent.agent_name,
                    task=task,
                    output=output,
                    start_time=agent_start,
                    end_time=datetime.now(),
                    duration=duration,
                )
            except Exception as e:
                print(f"âŒ Agent {agent.agent_name} failed: {str(e)}")
                raise

        with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:
            agent_outputs = list(executor.map(
                lambda agent: run_agent(agent, task), self.agents
            ))

        total_duration = (datetime.now() - start_time).total_seconds()
        print(f"\nğŸ All agents completed in {total_duration:.2f} seconds")
        print(f"ğŸ“Š Total responses collected: {len(agent_outputs)}")

        self.output_schema = MetadataSchema(
            swarm_id=uuid.uuid4().hex,
            task=task,
            description=self.description,
            agents=agent_outputs,
        )

        self.save_metadata()
        return self.transform_metadata_schema_to_str(self.output_schema)

    def run(self, task: Optional[str] = None, img: Optional[str] = None, *args, **kwargs):
        print(f"\nâš¡ Starting workflow execution")
        try:
            if not task:
                raise ValueError("No task provided")
                
            print(f"ğŸ“¨ Received task: {task[:100]}{'...' if len(task) > 100 else ''}")
            result = self._run(task, img, *args, **kwargs)
            print("\nğŸ‰ Workflow completed successfully")
            return result
            
        except Exception as e:
            print(f"\nğŸ”¥ Critical error: {str(e)}")
            raise

if __name__ == "__main__":
    print("ğŸ› ï¸ Starting workflow demo...")
    try:
        print("\nğŸ§ª Creating test agents...")
        agents = [
            Agent(
                agent_name=f"Test-Agent-{i}",
                system_prompt="You are a helpful AI assistant",
                model_name="gpt-4o",
                max_loops=1,
            ) for i in range(3)
        ]
        
        print("ğŸ”§ Configuring workflow...")
        workflow = ConcurrentWorkflow(
            agents=agents,
            metadata_output_path="demo_output.json",
            return_str_on=True,
        )

        print("\nğŸ“® Sending sample task...")
        task = "Explain quantum computing in simple terms"
        result = workflow.run(task)
        
        print("\nğŸ“„ Final result:")
        print(result)
        print("\nğŸ Demo completed successfully")

    except Exception as e:
        print(f"\nğŸ’¥ Demo failed: {str(e)}")
